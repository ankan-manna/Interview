# Spring Framework & Spring Boot Concepts

## 1. What is Spring?

Spring is an open-source application development framework for enterprise Java. It was created to simplify the development of complex enterprise applications by addressing the complexities of earlier Java EE specifications.

### Core Principle

The fundamental philosophy of Spring is to manage the various components of an application (objects) and their dependencies, allowing developers to focus purely on the application's business logic.

### Key Features

- **Inversion of Control (IoC)**: A design principle where the control of object creation and dependency management is inverted from the components themselves to a container (the Spring IoC container). This makes components loosely coupled and easier to test.
- **Dependency Injection (DI)**: A specific implementation of IoC where the Spring container "injects" the dependencies of an object into it, instead of the object creating or looking up its dependencies.

### Modules

Spring is modular, meaning you can use the parts you need without the rest. Key modules include:
- **Spring Core**: IoC and DI functionality.
- **Spring Data**: Simplifies database access.
- **Spring MVC**: Framework for building web applications (Model-View-Controller architecture).
- **Spring Security**: Authentication and authorization services.

---

## 2. What is Spring Boot?

Spring Boot is an extension of the Spring framework that aims to simplify the initial setup and development of new Spring applications. It is designed to get Spring applications up and running with minimal configuration.

### üí° The Problem Before Spring Boot (The Need for a New Solution)

Before Spring Boot, setting up a standard Spring MVC application required extensive and often repetitive configuration, primarily using XML or Java configuration classes.

| Problem (Pre-Spring Boot)        | Example Scenario                                                                                                                                                           |
| -------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **XML/Java Configuration Hell**    | To set up a simple web app, you needed to manually configure a `DispatcherServlet`, set up view resolvers, component scanning, etc., in files like `web.xml` and multiple Spring XML/Java config files. |
| **Dependency Management Nightmares** | You had to manually declare versions for every dependency (Spring Core, Spring Web, Hibernate, etc.). Mismatching versions could lead to runtime errors.                   |
| **Deployment Complexity**        | Applications were typically deployed as `.war` files to an external web server like Tomcat, which meant installing and configuring the server separately.                     |

### ‚ú® How Spring Boot Solves These Problems

Spring Boot introduced three key features to solve the pre-existing problems:

1.  **Auto-Configuration**: It automatically configures your Spring application based on the dependencies present on your classpath. For example, if you add the `spring-boot-starter-web` dependency, Spring Boot automatically configures Tomcat and Spring MVC.

2.  **Starter Dependencies**: These are convenient dependency descriptors that bring in a set of related, pre-tested, and version-managed transitive dependencies.
    - *Example*: Adding `spring-boot-starter-data-jpa` automatically includes Spring Data JPA, Hibernate, and the necessary Spring Core dependencies, all with compatible versions.

3.  **Embedded Servers**: It includes an embedded server (like Tomcat, Jetty, or Undertow) directly within the application's executable `.jar` file. This allows the application to be run as a standalone process (`java -jar your-app.jar`), eliminating the need for an external web server setup and simplifying deployment.

---

## 3. Spring Boot Project Structure

A typical Spring Boot project generated by the Spring Initializr has a standard structure that promotes convention over configuration.

### **src/main/java** - Business Logic/Source Code

- **`com.example.project`** (Base Package): Contains all your Java source files. Adhering to the package naming convention is crucial for component scanning to automatically find classes like controllers and services.
  - **`Application.java`** (Bootstrap/Main Class): The entry point of the application. It contains the `main()` method and is typically annotated with `@SpringBootApplication`, which combines `@Configuration`, `@EnableAutoConfiguration`, and `@ComponentScan`.
  - **`controller/`** (Controllers): Handles incoming web requests (HTTP) and returns the response. Annotated with `@RestController` or `@Controller`.
  - **`service/`** (Services/Business Layer): Contains the application's core business logic. Annotated with `@Service`.
  - **`repository/`** (Repositories/Data Access Layer): Handles all database (persistence) operations. Annotated with `@Repository` and often extends Spring Data interfaces like `JpaRepository`.

### **src/main/resources** - Configuration and Static Assets

- **`application.properties` or `application.yml`** (Configuration File): Used to configure application settings, such as the server port (`server.port`), database connection details (`spring.datasource.url`), and logging levels.
- **`static/`** (Static Assets): Stores static web content like CSS, JavaScript files, and images.
- **`templates/`** (View Templates): Stores server-side view templates (e.g., Thymeleaf, Freemarker) if you are building a traditional server-rendered web application.

### **src/test/java** - Test Code

Contains unit tests and integration tests for the application's components.

### **`pom.xml`** or **`build.gradle`** - Build Configuration File

This is the core configuration for your build tool (Maven or Gradle). It defines all project dependencies, the build process, and plugins.

---

## 4. What is Maven?

Maven is a powerful project management and build automation tool primarily used for Java projects. It defines a standard way to build projects, handle compilation, run tests, and manage dependencies.

### üéØ Key Concepts of Maven

- **POM (Project Object Model)**: This is an XML file named `pom.xml` that contains all the configuration and information for the project. It defines the project's dependencies, version, build goals, and plugins.
- **Convention over Configuration**: Maven enforces a standard directory layout (the structure mentioned above), so you don't need to manually configure the location of source code, resources, or tests.
- **Dependency Management**: This is one of Maven's most valuable features. It automatically downloads the required libraries (dependencies) from a central repository (Maven Central) and manages their transitive dependencies (dependencies of dependencies).

### üõ†Ô∏è How Maven Solved the Previous Problem (JAR Hell)

| Problem Before Maven (Old Ant/Manual Builds) | Solution with Maven                                                                                                                                                           |
| -------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **"JAR Hell" and Dependency Mismatch**: Developers had to manually download required `.jar` files from various sources and copy them into a project's `lib` folder. Maintaining compatibility between versions was a constant, manual nightmare. | **Standardized Dependency Management**: Maven uses the `pom.xml` to declare dependencies by group ID, artifact ID, and version. It handles fetching, caching, and managing transitive dependencies, ensuring a stable and repeatable build. |
| **Non-Standard Build Process**: Different projects had different scripts (e.g., Ant scripts) for compiling, cleaning, or packaging, making it difficult for new team members to ramp up. | **Standardized Build Lifecycle**: Maven defines a fixed set of phases (like `validate`, `compile`, `test`, `package`, `install`, `deploy`). Running `mvn clean package` performs the same steps across any Maven project. |

---

## 5. ORM, JPA, and Spring Data

### Summary

This section clarifies essential database-related concepts and terminology that are crucial for developers. The focus is on Object Relational Mapping (ORM), Java Persistence API (JPA), ORM frameworks, and how these relate to relational databases versus NoSQL databases like MongoDB. Additionally, it introduces Spring Data and explains how it simplifies database interactions in Java applications.

---

### Key Concepts Explained

#### Object Relational Mapping (ORM)

- **ORM** stands for **Object Relational Mapping**.
- It is a **technique** used to map **Java objects (classes)** to **tables in a relational database**.
- Example: A Java class `User` corresponds to a database table `Users`.
- ORM enables developers to perform database operations by manipulating Java objects, allowing them to work with databases using object-oriented programming concepts.
- **ORM frameworks** such as **Hibernate** provide implementations to automate this mapping.

#### Java Persistence API (JPA)

- **JPA** stands for **Java Persistence API**.
- It is a **specification** (a set of rules or interfaces) for ORM in Java.
- JPA does **not** provide an implementation; it only defines how ORM should be achieved.
- A **persistence provider** or **ORM tool** (like Hibernate) is required to implement JPA‚Äôs specifications.

| Term                 | Description                                              | Example                          |
| -------------------- | -------------------------------------------------------- | -------------------------------- |
| ORM                  | Technique to map objects to relational tables            | Java class `User` to table `Users` |
| JPA                  | Java Persistence API - a set of rules/interfaces for ORM | Annotations like `@Entity`       |
| Persistence Provider | Implementation of the JPA specification                  | Hibernate, EclipseLink, OpenJPA  |

#### Spring Data JPA

- **Spring Data JPA** is built **on top of JPA** to simplify database operations further.
- It provides a higher-level abstraction, reducing boilerplate code.
- It is **not** an ORM or persistence provider itself; it requires an underlying JPA implementation like Hibernate.

---

### Relational Databases vs. MongoDB

- **JPA and ORM** are designed for **relational databases** (e.g., MySQL, PostgreSQL) with pre-defined **schemas** and **tables**.
- **MongoDB** is a **NoSQL database** that uses **collections of documents** and has a **flexible or schemaless design**.
- Because of this different data model, **JPA and ORM tools are not applicable for MongoDB**.
- For MongoDB, **Spring Data MongoDB** acts as the persistence provider, offering an abstraction to interact with MongoDB in Spring applications.

---

### Methods to Interact with Databases in Spring Data

| Method               | Description                                                                             | Complexity                |
| -------------------- | --------------------------------------------------------------------------------------- | ------------------------- |
| **Query Method DSL** | Writing method names following conventions to automatically generate queries.             | Simple and convenient     |
| **Criteria API**     | Programmatic and dynamic query creation using a complex Domain-Specific Language (DSL). | More complex but powerful |

---

## 6. Core Spring Concepts in Detail

### 6.1. IOC (Inversion of Control) & Application Context

**IoC** is a design principle where the control of object creation and lifecycle is transferred from the programmer to a framework. In Spring, the **Application Context** (or IoC Container) acts as the factory that creates, configures, and manages objects (called **Beans**).

#### The Problem (Tight Coupling)

*Before IoC:*

```java
public class UserService {
    // Tightly coupled! You can't easily swap SQL for MongoDB or Mock for testing.
    private UserRepository repository = new SqlUserRepository(); 
}
```

#### The Solution (Dependency Injection)

*With IoC:*

```java
@Service
public class UserService {
    @Autowired
    private UserRepository repository; // Spring injects the implementation.
}
```

---

### 6.2. Annotations & Bean Scanning

#### @SpringBootApplication

This is a convenience annotation that combines three others:

1.  **`@Configuration`**: Designates the class as a source of bean definitions.
2.  **`@EnableAutoConfiguration`**: Tells Spring Boot to start adding beans based on classpath settings.
3.  **`@ComponentScan`**: Tells Spring to look for other components, configurations, and services in the current package and its sub-packages.

#### @Component

A generic stereotype for any Spring-managed component. `@Service`, `@Repository`, and `@Controller` are specializations of `@Component`.

---

### 6.3. Dependency Injection (@Autowired)

This annotation is used for automatic dependency injection. It tells the IoC container: *"Find a bean of this type and put it here."*

#### Field Injection

```java
@Autowired
private MyService myService;
```

*(Note: Constructor injection is generally preferred for required dependencies).*

---

### 6.4. Web Layer: Controllers & REST

#### @RestController vs @Controller

- **`@Controller`** was designed for returning Views (e.g., HTML pages).
- **`@RestController`** is a shortcut for `@Controller` + `@ResponseBody`. It automatically serializes return objects into JSON/XML, which is ideal for REST APIs.

#### HTTP Methods Mapping

| Annotation     | HTTP Method | CRUD Operation |
| :------------- | :---------- | :------------- |
| `@GetMapping`    | GET         | Read           |
| `@PostMapping`   | POST        | Create         |
| `@PutMapping`    | PUT         | Update         |
| `@DeleteMapping` | DELETE      | Delete         |

#### Request Data Binding (@RequestParam vs @PathVariable)

##### @RequestParam (Query Parameters)

Used for optional parameters, filtering, or sorting.

- **URL**: `/users?role=admin`
- **Code**:

  ```java
  @GetMapping("/users")
  public List<User> getUsers(@RequestParam String role) { ... }
  ```

##### @PathVariable (URL Path)

Used to identify a specific resource.

- **URL**: `/users/105`
- **Code**:

  ```java
  @GetMapping("/users/{id}")
  public User getUser(@PathVariable("id") Long userId) { ... }
  ```

---

### 6.5. Useful Response Wrappers

#### Optional<T>

- **Problem**: A database query might return nothing, leading to `NullPointerException`.
- **Solution**: Java 8's `Optional` is a container object which may or may not contain a non-null value.

  ```java
  Optional<User> userBox = repository.findById(99);
  if(userBox.isPresent()) { 
      return userBox.get(); 
  }
  ```

#### ResponseEntity<T>

- **Problem**: Returning a simple object defaults to an HTTP 200 (OK) status. What if you need to return a different status code (e.g., 201 Created, 404 Not Found)?
- **Solution**: Wrap the response body in a `ResponseEntity` to control the status code and headers.

  ```java
  @PostMapping("/users")
  public ResponseEntity<User> createUser(@RequestBody User user) {
      User saved = service.save(user);
      return new ResponseEntity<>(saved, HttpStatus.CREATED); // Returns 201
  }
  ```

---

## 7. Complete Real-Life Code Example

**Scenario**: A "Product Inventory" REST API.

### 7.1. The Entity (Data Model)

```java
@Entity
@Table(name = "products")
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    private Double price;
    
    // Getters and Setters...
}
```

### 7.2. The Repository (Data Access Layer)

```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    // Spring Data JPA creates a proxy bean for this interface at runtime
    List<Product> findByName(String name); 
}
```

### 7.3. The Service (Business Logic)

```java
@Service
public class ProductService {
    @Autowired
    private ProductRepository repository;

    public Product addProduct(Product p) {
        return repository.save(p);
    }

    public Product getProduct(Long id) {
        return repository.findById(id)
            .orElseThrow(() -> new RuntimeException("Product not found"));
    }
}
```

### 7.4. The Controller (Web Layer)

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {

    @Autowired
    private ProductService service;

    @PostMapping
    public ResponseEntity<Product> create(@RequestBody Product product) {
        Product created = service.addProduct(product);
        return new ResponseEntity<>(created, HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Product> getOne(@PathVariable Long id) {
        Product p = service.getProduct(id);
        return ResponseEntity.ok(p);
    }
    
    @GetMapping
    public List<Product> search(@RequestParam(required = false) String name) {
        // ... logic to search by name using service.findByName(name)
        return null; 
    }
}
```

---


## 1. Problem Before Spring (Why Spring Exists)

### Earlier Problems (Plain Java / Java EE)

* Too much **object creation using `new` keyword**
* Tight coupling between classes
* Difficult to test (no easy mocking)
* Manual configuration (XML heavy)
* Boilerplate JDBC code

```java
Service s = new ServiceImpl(); // tightly coupled
```

If `ServiceImpl` changes ‚Üí all dependent classes break.

üëâ **Spring solved this using IoC + Dependency Injection**.

---

## 2. IoC (Inversion of Control)

### What is IoC?

IoC means **you do NOT create objects**. The **Spring container creates and manages objects for you**.

### Why IoC?

* Loose coupling
* Easy testing
* Centralized object lifecycle management

### Example Without IoC

```java
Car car = new Car(new Engine());
```

### Example With IoC

```java
@Autowired
Car car;
```

Spring decides **which object**, **when**, and **how** to inject.

---

## 3. ApplicationContext (Spring Container)

### What is ApplicationContext?

It is the **IoC container** that:

* Creates beans
* Stores beans
* Injects dependencies
* Manages lifecycle

### Spring Boot automatically creates it using:

```java
SpringApplication.run(DemoApplication.class, args);
```

You usually don‚Äôt create it manually in Spring Boot.

---

## 4. How Spring Scans Beans

Spring scans classes using **classpath scanning**.

### How it Works

* Starts from **main class package**
* Scans all **sub-packages**
* Registers beans annotated with:

  * `@Component`
  * `@Service`
  * `@Repository`
  * `@Controller`

### Example

```
com.app
 ‚îú‚îÄ‚îÄ DemoApplication
 ‚îú‚îÄ‚îÄ controller
 ‚îú‚îÄ‚îÄ service
 ‚îî‚îÄ‚îÄ repository
```

All are scanned automatically.

---

## 5. @Component & Stereotype Annotations

### @Component

Generic way to make a class a Spring bean.

```java
@Component
public class EmailService {}
```

### Specialized Components

| Annotation  | Purpose                           |
| ----------- | --------------------------------- |
| @Service    | Business logic                    |
| @Repository | DB access + exception translation |
| @Controller | MVC controller                    |

All internally use `@Component`.

---

## 6. @SpringBootApplication (Very Important)

```java
@SpringBootApplication
public class DemoApplication {}
```

### Internally Equals To:

```java
@Configuration
@EnableAutoConfiguration
@ComponentScan
```

### @ComponentScan

* Scans **only the package & sub-packages of main class**
* External packages must be specified manually

```java
@ComponentScan(basePackages = "com.other")
```

---

## 7. @Autowired (Dependency Injection)

### What It Does

* Takes bean from IoC container
* Injects into required class

```java
@Service
public class OrderService {

    @Autowired
    PaymentService paymentService;
}
```

### Why Needed?

* No `new` keyword
* Easy to replace implementation
* Easy testing

---

## 8. @RestController

```java
@RestController
public class UserController {}
```

### Internally Equals To:

```java
@Controller
@ResponseBody
```

Means:

* Handles HTTP requests
* Returns JSON directly

---

## 9. Request Mapping Annotations

### @RequestMapping

```java
@RequestMapping(value = "/users", method = RequestMethod.GET)
```

### Shortcuts (Recommended)

| Annotation     | HTTP   | Purpose |
| -------------- | ------ | ------- |
| @GetMapping    | GET    | Read    |
| @PostMapping   | POST   | Create  |
| @PutMapping    | PUT    | Update  |
| @DeleteMapping | DELETE | Delete  |

### Example

```java
@GetMapping("/users")
public List<User> getUsers() {}
```

---

## 10. @RequestParam vs @PathVariable

### @RequestParam

```http
/users?age=20
```

```java
@GetMapping("/users")
public List<User> get(@RequestParam int age) {}
```

### @PathVariable

```http
/users/10
```

```java
@GetMapping("/users/{id}")
public User get(@PathVariable int id) {}
```

---

## 11. SQL vs NoSQL

| SQL          | NoSQL           |
| ------------ | --------------- |
| Table        | Collection      |
| Row          | Document/Object |
| Column       | Field           |
| Fixed schema | Flexible schema |

---

## 12. ORM (Object Relational Mapping)

### Problem Before ORM

* Manual SQL
* Manual ResultSet mapping

### ORM Solution

Maps **Java object ‚Üî DB table** automatically.

---

## 13. JPA, Hibernate, Spring Data JPA

### JPA

* Specification (rules)

### Hibernate

* Implementation of JPA

### Spring Data JPA

* Reduces boilerplate
* Auto query generation

```java
public interface UserRepo extends JpaRepository<User, Long> {}
```

---

## 14. Application Flow (Very Important)

```
Controller ‚Üí Service ‚Üí Repository ‚Üí Database
```

Each layer has a single responsibility.

---

## 15. MongoRepository vs CrudRepository

### MongoRepository

```java
public interface UserRepo extends MongoRepository<User, String> {}
```

### CrudRepository (SQL)

```java
public interface UserRepo extends CrudRepository<User, Long> {}
```

---

## 16. MongoDB Annotations

```java
@Document(collection = "users")
public class User {
    @Id
    private String id;
}
```

---

## 17. JPA Annotations

```java
@Entity
@Table(name = "users")
public class User {

    @Id
    private Long id;

    @Column(name = "email")
    private String email;
}
```

---

## 18. How to Make Bean of an Interface?

### Using Implementation Class

```java
@Service
public class PaymentServiceImpl implements PaymentService {}
```

Spring injects implementation automatically.

### Multiple Implementations

```java
@Qualifier("upi")
@Autowired
PaymentService paymentService;
```

---

## 19. Optional<Entity>

### Problem Before

```java
User user = repo.findById(id); // may cause NPE
```

### Solution

```java
Optional<User> user = repo.findById(id);
```

```java
user.orElseThrow(() -> new RuntimeException("Not Found"));
```

---

## 20. ResponseEntity<>

### Why Needed?

* Control HTTP status
* Control headers
* Better API design

```java
return ResponseEntity
       .status(HttpStatus.CREATED)
       .body(user);
```


---

# 8. Spring Security

This section explains how to secure a Spring Boot application using **Spring Security**, covering authentication, authorization, password encoding, and endpoint protection.

---

### Core Concepts Explained

- **Authentication vs Authorization**
  - **Authentication:** Verifying identity (*Who are you?*).
  - **Authorization:** Determining access rights (*What can you do?*).

- **Spring Security**
  - A framework that handles both authentication and authorization.
  - By default, it secures **all endpoints** and enables **HTTP Basic Authentication**.

- **Password Encoding with BCrypt**
  - It is critical to **never store passwords in plain text**.
  - `BCryptPasswordEncoder` is used to hash passwords before saving them. It generates a salted hash, making it secure.

- **Stateless Session Management**
  - For REST APIs, it's best practice to be **stateless**. Each request must be authenticated independently.
  - This is configured by setting `sessionCreationPolicy(SessionCreationPolicy.STATELESS)`.

- **CSRF (Cross-Site Request Forgery) Protection**
  - CSRF protection is enabled by default but is typically disabled for stateless REST APIs that are not called from a browser.

---

### Implementation Steps

1.  **Add Dependency**: Add `spring-boot-starter-security` to `pom.xml`.
2.  **Create Security Configuration**: Create a class annotated with `@Configuration` and `@EnableWebSecurity`.
3.  **Configure `HttpSecurity`**: Define rules for which endpoints are public and which are protected.
4.  **Implement `UserDetailsService`**: Create a service that loads user-specific data from the database.
5.  **Create a `PasswordEncoder` Bean**: Define a `BCryptPasswordEncoder` bean to be used for password hashing.
6.  **Refactor Controllers**: Ensure controllers get user information from the security context rather than insecure request parameters.

---

### Example Security Configuration

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Autowired
    private UserDetailsServiceImpl userDetailsService;
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
            
        return http.build();
    }
}
```

---

### FAQ

**Q1: What happens when the Spring Security dependency is added?**
A1: All endpoints become secured by default, requiring authentication.

**Q2: Why is BCrypt used for password encoding?**
A2: BCrypt hashes passwords securely by adding a random "salt" to each password before hashing, which protects against rainbow table attacks.

**Q3: Why disable CSRF for REST APIs?**
A3: CSRF is an attack vector for browser-based, session-oriented applications. Since stateless REST APIs don't rely on browser sessions, this protection is often unnecessary.

---

---

## 1. Problem Before Lombok (Why Lombok Exists)

### Earlier Problems in Java POJOs

* Too much boilerplate code
* Repeating getters, setters, constructors
* Hard to maintain and error‚Äëprone

### Example Without Lombok

```java
public class User {
    private String id;
    private String name;

    public User() {}

    public User(String id, String name) {
        this.id = id;
        this.name = name;
    }

    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
}
```

üëâ **Lombok removes this boilerplate at compile time**.

---

## 2. Lombok (What & Why)

### What is Lombok?

Lombok is a **Java library** that automatically generates common code like:

* Getters / Setters
* Constructors
* Builders
* `toString()`, `equals()`, `hashCode()`

### Why Use Lombok?

* Cleaner code
* Better readability
* Faster development

---

## 3. @Data

```java
@Data
public class User {
    private String id;
    private String name;
}
```

### What It Generates

* Getters & Setters
* `toString()`
* `equals()` & `hashCode()`
* **RequiredArgsConstructor** (‚ö†Ô∏è NOT NoArgs by default)

‚ö†Ô∏è **If framework needs no‚Äëargs constructor (JPA/Mongo), add it explicitly**.

---

## 4. @NoArgsConstructor

```java
@NoArgsConstructor
public class User {}
```

### Why Needed?

* Required by JPA
* Required by MongoDB mapping
* Required for serialization

---

## 5. @AllArgsConstructor

```java
@AllArgsConstructor
public class User {
    private String id;
    private String name;
}
```

Used when you want to create objects in one line.

---

## 6. @Builder (Builder Pattern)

### Problem Before

Constructors with many arguments are confusing.

### Solution

```java
@Builder
public class User {
    private String id;
    private String name;
}
```

```java
User user = User.builder()
    .id("1")
    .name("Ankan")
    .build();
```

---

## 7. @Value (Immutable Classes)

```java
@Value
public class Token {
    String token;
    Long expiry;
}
```

### What It Does

* Makes fields `final`
* No setters
* Thread‚Äësafe
* Generates all‚Äëargs constructor

---

## 8. @Getter & @Setter

```java
@Getter
@Setter
public class User {
    private String name;
}
```

You can also use at field level.

---

## 9. MongoDB Configuration (application.properties)

```properties
spring.data.mongodb.host=localhost
spring.data.mongodb.port=27017
spring.data.mongodb.database=yourDatabaseName

spring.data.mongodb.auto-index-creation=true
```

### Why auto-index creation?

Ensures Mongo indexes are created automatically at startup.

---

## 10. @Indexed(unique = true)

```java
@Document(collection = "users")
public class User {

    @Id
    private String id;

    @Indexed(unique = true)
    private String email;
}
```

### Why Needed?

* Prevent duplicate records
* Enforce uniqueness at DB level

---

## 11. @NonNull

```java
@NonNull
private String name;
```

### What It Does

* Lombok generates null checks
* Throws `NullPointerException` early

---

## 12. @DBRef (Mongo Reference)

```java
@DBRef
private Order order;
```

### Important Notes

* Creates reference between documents
* **No automatic cascade delete**
* Avoid excessive use (performance hit)

---

## 13. CascadeType.ALL (Relational DB)

```java
@OneToMany(cascade = CascadeType.ALL)
private List<Order> orders;
```

### Cascade Delete Meaning

* Parent delete ‚Üí child delete
* **Only works in relational DB**

### MongoDB ‚ùå

* Mongo does NOT support cascade automatically
* Must handle manually or via custom logic

---

## 14. @Transient

```java
@Transient
private String tempValue;
```

### Why?

* Field not stored in DB
* Used for calculated or temporary data

---

## 15. Transactions (Problem Before)

### Earlier Problem

Multiple DB operations:

* One succeeds
* Another fails

‚Üí **Data inconsistency**

---

## 16. ACID Properties

| Property    | Meaning        |
| ----------- | -------------- |
| Atomicity   | All or nothing |
| Consistency | Valid state    |
| Isolation   | No dirty reads |
| Durability  | Data persists  |

---

## 17. @Transactional

```java
@Transactional
public void createOrder() {
    saveUser();
    saveOrder();
}
```

### What It Ensures

* Atomic execution
* Rollback on failure

---

## 18. Rollback Rule (Very Important)

### ‚ùå This Will NOT Rollback

```java
@Transactional
public void test() {
    try {
        saveA();
        saveB();
    } catch (Exception e) {
        // swallowed
    }
}
```

### ‚úÖ Correct Ways

#### Option 1: Throw RuntimeException

```java
throw new RuntimeException(e);
```

#### Option 2: Manual Rollback

```java
TransactionAspectSupport
    .currentTransactionStatus()
    .setRollbackOnly();
```

---

## 19. Transaction Management Annotations

### @EnableTransactionManagement

```java
@Configuration
@EnableTransactionManagement
public class TransactionConfig {}
```

Enables Spring‚Äôs transaction support.

---

## 20. PlatformTransactionManager

### What is It?

Central interface to manage transactions.

---

## 21. MongoTransactionManager

```java
@Bean
public PlatformTransactionManager falana(
        MongoDatabaseFactory dbFactory) {
    return new MongoTransactionManager(dbFactory);
}
```

Handles MongoDB transactions.

---

## 22. MongoDatabaseFactory

### Purpose

* Creates MongoDB database connections

### Default Implementation

```text
SimpleMongoClientDatabaseFactory
```

Spring Boot auto‚Äëconfigures it using connection string.

---

## 23. Full Transaction Configuration Example

```java
@Configuration
@EnableTransactionManagement
public class TransactionConfig {

    @Bean
    public PlatformTransactionManager falana(
            MongoDatabaseFactory dbFactory) {
        return new MongoTransactionManager(dbFactory);
    }
}
```

### Note

* Often **no explicit usage**
* Required for multi‚Äëdocument Mongo transactions

---

## Summary

‚úî Lombok removes boilerplate
‚úî Mongo annotations control indexing & mapping
‚úî Transactions ensure data safety
‚úî Mongo transactions require explicit config

---

---

## 1. Problem Before Java-based Configuration

### Earlier Problems (XML Era)

* Heavy XML configuration (`applicationContext.xml`, `spring-security.xml`)
* Hard to read & maintain
* No type safety
* Difficult refactoring

```xml
<bean id="userService" class="com.app.UserService" />
```

üëâ **Spring moved to Java-based configuration using annotations**.

---

## 2. @Configuration

### What It Is

```java
@Configuration
public class AppConfig {}
```

### Why Needed?

* Marks a class as a **source of bean definitions**
* Replacement for XML config
* Ensures beans are **singleton by default**

### Important Detail

Spring creates a **proxy** for `@Configuration` classes to ensure:

* Same bean instance is returned every time

---

## 3. @Bean

### What It Does

Marks a method whose return value is managed by Spring as a bean.

```java
@Bean
public ObjectMapper objectMapper() {
    return new ObjectMapper();
}
```

### Why Needed?

* When you **don‚Äôt own the class** (3rd party libs)
* When you need **custom initialization logic**

---

## 4. Transaction Problem (Why Transaction Management Exists)

### Earlier Issue

Multiple DB operations:

* One succeeds
* Another fails

‚û° Data inconsistency

---

## 5. @EnableTransactionManagement

```java
@EnableTransactionManagement
@Configuration
public class TransactionConfig {}
```

### What It Does

* Enables Spring‚Äôs **AOP-based transaction handling**
* Activates `@Transactional`

Without this ‚Üí `@Transactional` does nothing.

---

## 6. PlatformTransactionManager

### What Is It?

```java
public interface PlatformTransactionManager {}
```

### Why Important?

* Central abstraction for transaction handling
* Different DBs ‚Üí different implementations

| Database | Manager                      |
| -------- | ---------------------------- |
| JDBC     | DataSourceTransactionManager |
| JPA      | JpaTransactionManager        |
| Mongo    | MongoTransactionManager      |

---

## 7. MongoDatabaseFactory

### What It Is

```java
public interface MongoDatabaseFactory {}
```

### Responsibility

* Creates MongoDB connections
* Provides `MongoDatabase` instances

### Default Implementation

```text
SimpleMongoClientDatabaseFactory
```

Spring Boot auto-configures this using connection string.

---

## 8. MongoTransactionManager

```java
@Bean
public PlatformTransactionManager falana(
        MongoDatabaseFactory dbFactory) {
    return new MongoTransactionManager(dbFactory);
}
```

### Why Needed?

* MongoDB **does not support transactions by default**
* Required for **multi-document transactions**

‚ö† Mongo transactions require:

* Replica set
* WiredTiger engine

---

## 9. Complete Transaction Configuration Example

```java
@Configuration
@EnableTransactionManagement
public class TransactionConfig {

    @Bean
    public PlatformTransactionManager falana(
            MongoDatabaseFactory dbFactory) {
        return new MongoTransactionManager(dbFactory);
    }
}
```

Often looks unused, but **required internally**.

---

## 10. Web Security Problem (Why Spring Security Exists)

### Earlier Problems

* Manual authentication logic
* No standard authorization flow
* Repeated code across projects

üëâ Spring Security provides **standard, pluggable security**.

---

## 11. @EnableWebSecurity

```java
@EnableWebSecurity
@Configuration
public class SecurityConfig {}
```

### What It Does

* Enables Spring Security filter chain
* Activates web-level security

---

## 12. WebSecurityConfigurerAdapter (Legacy but Important)

```java
public class WebSecurityConfig
        extends WebSecurityConfigurerAdapter {}
```

### Purpose

* Customize authentication & authorization
* Override default security behavior

‚ö† Deprecated in Spring Security 5.7+
Still important for **legacy & interview questions**.

---

## 13. configure(HttpSecurity http)

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .csrf().disable()
        .authorizeRequests()
        .antMatchers("/public/**").permitAll()
        .anyRequest().authenticated()
        .and()
        .httpBasic();
}
```

### What It Controls

* URL access rules
* Authentication mechanisms
* CSRF, CORS, sessions

---

## 14. Typical Security Flow

```
Request ‚Üí Security Filter Chain ‚Üí Authentication ‚Üí Authorization ‚Üí Controller
```

---

## 15. Modern Alternative (FYI)

```java
@Bean
SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    return http
        .authorizeHttpRequests()
        .anyRequest().authenticated()
        .and()
        .build();
}
```

Used instead of `WebSecurityConfigurerAdapter` in newer projects.

---

## Summary

‚úî @Configuration + @Bean replace XML
‚úî Transaction manager abstracts DB differences
‚úî Mongo transactions need explicit config
‚úî Spring Security centralizes authentication & authorization

---


